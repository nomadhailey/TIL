##브라우저의 렌더링 과정

#### 브라우저의 렌더링 과정

브라우저의 역할은 사용자의 요청을 서버에 전달하고 그 결과를 화면에 나타내는 과정인데 렌더링은 화면에 나타내는 과정을 의미한다.

1. 브라우저 주소창에 [www.naver.com](http://www.naver.com/) 치면 루트요청(/, 스킴(scheme)과 호스트(host) 만으로 구성된 URI에 의한 요청)이 네이버 서버로 전송

2. 일반적으로 서버는 루트 요청에 대해 암묵적으로 정적파일 index.html을 응답하도록 기본 설정되어 있음. 즉 www.naver.com은 www.naver.com/index.html과 같은 요청

3.  HTML문서는 문자열로 이루어진 순수한 텍스트. 순수한 텍스트인 HTML 문서를 브라우저에 시각적인 픽셀로 렌더링하려면, 브라우저 렌더링 엔진은 HTML 문서를 파싱(바이트->문자->토큰->노드->DOM)하여 브라우저가 이해할 수 있는 자료구조(객체)인 DOM으로 변환하여 메모리에 저장해야 한다.(즉 DOM은 HTML 문서를 파싱한 결과물)

4. 렌더링 엔진은 DOM을 생성해 나가다가 CSS를 로드하는 link 태그나 style 태그를 만나면 DOM 생성을 일시 중단하고 css를 파싱하여(link 태그의 href 어트리뷰트에 지정된 CSS 파일을 서버에 요청하여 로드한 CSS 파일이나 style 태그 내의 CSS) CSSOM(CSS Object Model)을 생성

5. 이후 CSS 파싱을 완료하면 HTML 파싱이 중단된 지점부터 다시 HTML을 파싱하기 시작하여 DOM 생성을 재개한다. 

6. 완성된 DOM과 CSSOM은 렌더링을 위해 렌더 트리(render tree)로 결합된다.

   렌더 트리는 렌더링을 위한 트리 구조의 자료구조다. 따라서 브라우저 화면에 렌더링되지 않는 노드(예: meta 태그, script 태그 등)와 CSS에 의해 비표시(예: display: none)되는 노드들은 포함하지 않는다. 다시 말해, 렌더 트리는 브라우저 화면에 렌더링되는 노드만으로 구성된다.

   이후 완성된 렌더 트리는 각 HTML 요소의 레이아웃(위치와 크기)을 계산하는 데 사용되며 브라우저 화 면에 픽셀을 렌더링하는 페인팅(painting) 처리에 입력된다.

7. 렌더링 엔진이 HTML을 한 줄씩 파싱하며 DOM을 생성해 나가다가 자바스크립트 파일을 로드하는 script태그(script 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 서버에 요청하여 로드한 자바스크립트 파일이나 script 태그 내의 자바스크립트 코드)를 만나면, 이를 파싱하기 위해 자바스크립트 엔진에 제어권을 넘긴다. 

8. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST(Abstract Syntax Tree)를 생성하고 바이트코드로 변환하여 실행한다. 이때 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있다. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다.

9. 이후 자바스크립트 파싱과 실행이 종료되면 렌더링 엔진으로 다시 제어권을 넘겨 HTML 파싱이 중단된 지점부터 다시 HTML 파싱을 시작하여 DOM 생성을 재개한다.

####reflow vs. repaint

reflow는 DOM노드의 레이아웃에 영향을 주는 요소들이 바뀌면(width, height 등등) 영향을 받는 모든 노드들의 수치를 다시 계산해서 <u>렌더트리를 재생성하는 과정</u>.

repaint는 Reflow 과정으로 렌더트리가 재생성되고, 이렇게 생성된 렌더트리를 브라우저에 우리가 보는 화면으로 그리는 과정.

레이아웃에 영향이 없는 변경은 리플로우 없이 리페인트만 실행된다.

##### reflow, repaint 최적화 방법

그렇다면 결국 뷰를 빠르게 그리기 위해서 Reflow와 Repaint를 최소한으로 그려야 합니다. 

* **클래스 변화에 따른 스타일을 변경할 경우 최대한 DOM트리 끝단의 노드를 선택하자.**

  한마디로 Reflow의 반경을 최소한으로 하자는 의미입니다. 레이아웃에 영향을 받는 노드들이 적으면 적을수록 지출되는 비용이 적어지겠죠.

* **인라인 스타일을 배제하자.**

* **애니메이션을 가진 노드는 position: fixed, position: absolute를 줘서 전체 노드트리에서 분리시키자.**

  position 'fixed', 'absolute' 속성이 지정된 노드는 전체 노드트리에서 분리됩니다. (이 속성이 레이아웃에 영향을 받지 않는 이유겠죠.) 따라서 Reflow 과정은 발생하지 않고 Repaint 비용만 들어가기 때문에 훨씬 비용을 덜 쓸 수 있겠죠.

* **테이블 레이아웃은 피하자.**

  페이지가 테이블 레이아웃으로 구성되어 있으면, 이를 모두 계산한 후에 화면에 그립니다. 그러면 UX측면에서 좋지 않겠죠?

* **cssText 혹은 클래스를 지정해서 스타일을 입히자.**

  JavaScript 코드 안에서 스타일을 줄 때마다 매번 DOM을 호출해서 입히지 말자는 얘기입니다. 클래스를 줘서 css 파일 안에서 스타일을 주거나, cssText를 통해 한 번에 스타일을 주는 것이 좋습니다.

* **캐쉬를 활용해 Reflow 수행 횟수를 줄이자.**

  중복되는 수치에 대한 스타일 정보를 변수로 저장해 캐싱하는게 좋습니다. 예를 들어, container 역할을 하는 div 태그의 너비를 두, 세번 DOM을 호출해서 사용하는 것보다는 이 너비를 하나의 변수로 캐싱해서 사용하는 것이 Reflow 비용을 줄일 수 있습니다. 왜냐면 이렇게 스타일 정보를 요청할 때마다 정확한 정보를 전달하기 위해 레이아웃 변경 정보를 담는 큐를 싹 다 비우고 다시 변경사항을 큐에 담기 때문이죠.

* **DOM 사용을 최소화하자.**

#### body 요소의 가장 아래에 자바스크립트를 위치시키는 이유?

1) DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작한다면 에러가 발생할 수 있다. 

2) 자바스크립트 로딩/파싱/실행으로 인해 HTML 요소들의 렌더링에 지장받는 일이 발생하지 않아 페 이지 로딩 시간이 단축된다

#### script 태그의 async / defer 어트리뷰트

자바스크립트 파싱에 의한 DOM 생성이 중단(blocking)되는 문제를 근본적으로 해결하기 위해 HTML5부터 script 태그에 async와 defer 어트리뷰트가 추가되었다. async와 defer 어트리뷰트는 src 어트리뷰트를 통해 외부 자바스크립트 파일을 로드하는 경우에만 사용할 수 있다. 즉, src 어트리뷰트가 없는 인라인 자바스크립트에는 사용할 수 없다

##### async 어트리뷰트

HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행된다. 단, 자바스크립트의 파싱과 실행은 자바스크립트 파일의 로드가 완료된 직후 진행되며, 이때 HTML 파싱이 중단된다. 여러 개의 script 태그에 async 어트리뷰트를 지정하면 script 태그의 순서와는 상관없이 로드가 완료 된 자바스크립트부터 먼저 실행되므로 순서가 보장되지 않는다. 따라서 순서 보장이 필요한 script 태그 에는 async 어트리뷰트를 지정하지 않아야 한다. async 어트리뷰트는 IE10 이상에서 지원된다.

![image-20201114060823357](C:\Users\haeri\AppData\Roaming\Typora\typora-user-images\image-20201114060823357.png)

#####defer 어트리뷰트

async 어트리뷰트와 마찬가지로 HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행된다. 단, 자바스크립트의 파싱과 실행은 HTML 파싱이 완료된 직후, 즉 DOM 생성이 완료 된 직후(이때 DOMContentLoaded 이벤트가 발생한다) 진행된다. 따라서 DOM 생성이 완료된 이 후 실행되어야 할 자바스크립트에 유용하다. defer 어트리뷰트는 IE10 이상에서 지원된다. IE6 ~ 9 에서도 지원되기는 하만 정상적으로 동작하지 않을 수 있다.

![image-20201114060905068](C:\Users\haeri\AppData\Roaming\Typora\typora-user-images\image-20201114060905068.png)

